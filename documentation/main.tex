\documentclass[
paper = a4,
fontsize = 12pt,
numbers=noenddot,
headsepline = true,
footsepline = true,
plainfootsepline = true,
parskip,								        
listof = nottotoc,
bibliography = totoc,
index = totoc,
twoside = false
]{scrartcl}

% -------------------------------------------------
% Pakete: Sprache, Schrift, Layout
% -------------------------------------------------
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} % bei pdflatex
\usepackage{lmodern}

\usepackage{color} 								% Schrift färben
\usepackage{tikz}
\usetikzlibrary{arrows.meta, calc, positioning, shapes.symbols, shapes.misc}

\usepackage{geometry}
\geometry{
    left=3cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}

\usepackage{setspace}
\onehalfspacing

% -------------------------------------------------
% Mathe, Grafiken, Tabellen
% -------------------------------------------------
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{hyperref}

% -------------------------------------------------
% Kopf- und Fußzeilen (KOMA-konform, einheitlich)
% -------------------------------------------------
\usepackage{scrlayer-scrpage}
\clearpairofpagestyles

\usepackage{xcolor}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}

% Automatische Marken für scrartcl: section
\automark{section}

% Linienfarbe
\addtokomafont{headsepline}{\color{mygray}}
\addtokomafont{footsepline}{\color{mygray}}

% Kopfzeile: rechts Abschnittsname
\ohead{\color{mygray}\leftmark}

% Fußzeile: Seitenzahl mittig
\cfoot{\color{mygray}\pagemark}

% Auch für plain-Seiten (TOC etc.) erzwingen
\pagestyle{scrheadings}

\setlength{\footskip}{1.2cm}


% -------------------------------------------------
% Titelinformationen
% -------------------------------------------------
\title{
    \textbf{\\[2cm] Dokumentation zum XML-Projekt im Master-Modul Internettechnologien}     \vspace{1cm}
}

\author{
    \Large{\textbf{Lennart Mende}} \\
    \Large{\textbf{Richard Mende}} \\[2cm]
    \large{HTWK Leipzig} \\
    \large{Wintersemester 2025/26} \\
    \large{Prof. Dr.-Ing. Andreas Pretschner}
}

\date{\vspace{3cm}\large{\today}}

% =================================================
\begin{document}
% =================================================

% -----------------------------
% Titelseite
% -----------------------------
\maketitle

\thispagestyle{empty}

\newpage

% -----------------------------
% Inhaltsverzeichnis
% -----------------------------
\tableofcontents

\thispagestyle{empty}
% \vspace{2cm}

% -----------------------------
% Abbildungs- und Tabellenverzeichnis (optional)
% -----------------------------
% \listoffigures

% \vspace{2cm}

% \listoftables
\newpage
\setcounter{page}{1}

% =================================================
% Hauptteil
% =================================================

\section{Projekübersicht}

\subsection{Zielstellung}

Als Grundlage dieses Projekts dient das Anlegen eines XML-Datensatzes. Dieser sollte aus mehreren Objekten mit jeweils mindestens einem Attribut und einer Datensequenz bestehen. Die anschließende Aufgabe besteht im Erstellen einer XSD-Schemadatei. Damit kann validiert werden, ob die gegebene XML-Datei die gewünschte Struktur erfüllt und alle benötigten Angaben enthält. Darüber hinaus soll eine in \textit{EditiX} automatisch generierte XSD-Schemadatei erstellt werden.

Der zweite Teil des Projekts befasst sich mit der Transformation der XML-Datei. Zunächst sollen die Daten auf einer HTML-Seite dargestellt werden. Dazu muss zunächst die XSLT-Transformationsdatei erzeugt werden. Darüber hinaus soll die Transformation in ein PDF erfolgen. Hierfür wurde die FOP-Transformation eingesetzt. Eine übersichtliche Darstellung dieser Transformationen zeigt Abbildung \ref{fig:files}.

Der dritte Aufgabenteil beschäftigt sich mit der XML-Programmierung. Dabei soll eine Apllikation erstellt werden, welche die Validierung, Abfrage und Transformation der XML-Datei ermöglicht.

\enlargethispage{1\baselineskip}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[>=Stealth, thick, node distance=2.5cm and 3cm]

% ---------------- Parameter ----------------
\def\filewidth{1.8}
\def\fileheight{2.7}
\def\fold{0.5}
\def\scale{1}

% ---------------- XML ----------------
\node (xml) at (0,0) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0) -- (0,\fileheight) --
(\filewidth-\fold,\fileheight) --
(\filewidth,\fileheight-\fold) --
(\filewidth,0) -- cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight) --
(\filewidth-\fold,\fileheight-\fold) --
(\filewidth,\fileheight-\fold) -- cycle;
\draw (\filewidth-\fold,\fileheight) -- (\filewidth,\fileheight-\fold);
\node[anchor=center, text width=\filewidth cm, align=center]
at (\filewidth/2,\fileheight/2) {XML};
\end{tikzpicture}
};

% ---------------- XSD ----------------
\node (xsd) [below=5cm of xml] {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0) -- (0,\fileheight) --
(\filewidth-\fold,\fileheight) --
(\filewidth,\fileheight-\fold) --
(\filewidth,0) -- cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight) --
(\filewidth-\fold,\fileheight-\fold) --
(\filewidth,\fileheight-\fold) -- cycle;
\draw (\filewidth-\fold,\fileheight) -- (\filewidth,\fileheight-\fold);
\node[anchor=center, text width=\filewidth cm, align=center]
at (\filewidth/2,\fileheight/2) {XSD};
\end{tikzpicture}
};

\draw[<->] (xml) -- (xsd);

% ---------------- XSLT ----------------
\node (xslt) [right=of xml] {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0) -- (0,\fileheight) --
(\filewidth-\fold,\fileheight) --
(\filewidth,\fileheight-\fold) --
(\filewidth,0) -- cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight) --
(\filewidth-\fold,\fileheight-\fold) --
(\filewidth,\fileheight-\fold) -- cycle;
\draw (\filewidth-\fold,\fileheight) -- (\filewidth,\fileheight-\fold);
\node[anchor=center, text width=\filewidth cm, align=center]
at (\filewidth/2,\fileheight/2) {XSLT};
\end{tikzpicture}
};

% ---------------- DocBook ----------------
\node (docbook) [below=5cm of xslt] {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0) -- (0,\fileheight) --
(\filewidth-\fold,\fileheight) --
(\filewidth,\fileheight-\fold) --
(\filewidth,0) -- cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight) --
(\filewidth-\fold,\fileheight-\fold) --
(\filewidth,\fileheight-\fold) -- cycle;
\draw (\filewidth-\fold,\fileheight) -- (\filewidth,\fileheight-\fold);
\node[anchor=center, text width=\filewidth cm, align=center]
at (\filewidth/2,\fileheight/2) {DocBook};
\end{tikzpicture}
};

% ---------------- HTML ----------------
\node (html) [right=of xslt] {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0) -- (0,\fileheight) --
(\filewidth-\fold,\fileheight) --
(\filewidth,\fileheight-\fold) --
(\filewidth,0) -- cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight) --
(\filewidth-\fold,\fileheight-\fold) --
(\filewidth,\fileheight-\fold) -- cycle;
\node[anchor=center, text width=\filewidth cm, align=center]
at (\filewidth/2,\fileheight/2) {HTML};
\end{tikzpicture}
};

% ---------------- PDF ----------------
\node (pdf) [right=of docbook] {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0) -- (0,\fileheight) --
(\filewidth-\fold,\fileheight) --
(\filewidth,\fileheight-\fold) --
(\filewidth,0) -- cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight) --
(\filewidth-\fold,\fileheight-\fold) --
(\filewidth,\fileheight-\fold) -- cycle;
\node[anchor=center, text width=\filewidth cm, align=center]
at (\filewidth/2,\fileheight/2) {PDF};
\end{tikzpicture}
};

% ---------------- XSL-FO (ECHT ZENTRIERT) ----------------
\node (fo) at ($(xslt)!0.5!(docbook)$) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0) -- (0,\fileheight) --
(\filewidth-\fold,\fileheight) --
(\filewidth,\fileheight-\fold) --
(\filewidth,0) -- cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight) --
(\filewidth-\fold,\fileheight-\fold) --
(\filewidth,\fileheight-\fold) -- cycle;
\node[anchor=center, text width=\filewidth cm, align=center]
at (\filewidth/2,\fileheight/2) {XSL--FO};
\end{tikzpicture}
};

% ---------------- Pfeile ----------------
\draw[->] (xml) -- (xslt);
\draw[->] (xml) -- (docbook);
\draw[->] (xslt) -- (html);
\draw[->] (xml) -- (fo);
\draw[->] (fo) -- (pdf);
\draw[->] (docbook) -- (pdf);

\end{tikzpicture}
\caption{Übersicht der Dokumenttypen und Transformationspfade}
\label{fig:files}
\end{figure}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    >=Stealth,
    thick,
    node distance=2.8cm and 2.5cm,
    scale=0.85,
    transform shape
]

% ---------------- Parameter ----------------
\def\filewidth{1.8}
\def\fileheight{2.7}
\def\fold{0.5}
\def\scale{1}

% ---------- Makro für Dateiblock ----------
\newcommand{\fileblock}[1]{%
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0) -- (0,\fileheight) --
(\filewidth-\fold,\fileheight) --
(\filewidth,\fileheight-\fold) --
(\filewidth,0) -- cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight) --
(\filewidth-\fold,\fileheight-\fold) --
(\filewidth,\fileheight-\fold) -- cycle;
\draw (\filewidth-\fold,\fileheight) -- (\filewidth,\fileheight-\fold);
\node[anchor=center, text width=\filewidth cm, align=center]
at (\filewidth/2,\fileheight/2) {#1};
\end{tikzpicture}
}

% ================= Erste Ebene =================
\node (xml) at (0,0) {\fileblock{XML}};
\node (xsd) [right=6cm of xml] {\fileblock{XSD}};

\draw[<->] (xml) -- (xsd);

% ================= Zweite / Dritte Ebene =================
\node (xslt) [below left=of xml] {\fileblock{XSLT}};
\node (xsl)  [below right=of xml] {\fileblock{XSL}};

\draw[->] (xml) -- (xslt);
\draw[->] (xml) -- (xsl);

% ================= Vierte / Fünfte Ebene =================
\node (html) [below=of xslt] {\fileblock{HTML}};
\node (fo)   [below=of xsl]  {\fileblock{XSL--FO}};

\draw[->] (xslt) -- (html);
\draw[->] (xsl) -- (fo);

% ================= Sechste / Siebte Ebene =================
\node (pdf) [below=of fo] {\fileblock{PDF}};
\draw[->] (fo) -- (pdf);

\end{tikzpicture}
\caption{Transformations- und Validierungsbeziehungen zwischen XML-basierten Dokumentformaten}
\label{fig:files2}
\end{figure}



\subsection{Grundlegende Informationen}
Für eine einfachere Bearbeitung dieses Projekts und zur Versionskontrolle wurde ein \textit{GitHub-Repository} erstellt. Dieses vereinfacht insbesondere die Zusammenarbeit mehrerer Teilnehmer. Das \textit{Repository} enthält alle angehängten Dateien und ermöglicht den Zugriff auf ältere Zwischenstände.


Abb. \ref{tab:overview_files} die Struktur der angehängten Dateien im GitHub-Repositorium.

\begin{figure}[H]
\centering
\begin{forest}
for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    align=left,
    tier/.option=level,
    inner xsep=1.5pt,
    edge path={
        \noexpand\path [draw, \forestoption{edge}]
        (!u.parent anchor) -- +(5pt,0) |- (.child anchor)\forestoption{edge label};
    },
}
[project, parent anchor=east, child anchor=west
    [assets, parent anchor=east, child anchor=west
        [output, parent anchor=east, child anchor=west
            [products.fo]
            [products.html]
            [products.pdf]
        ]
        [src, parent anchor=east, child anchor=west
            [products-automatic-generated.xsd]
            [products-to-html.xslt]
            [products-to-pdf.xsl]
            [products.xml]
            [products.xsd]
        ]
    ]

    [documentation, parent anchor=east, child anchor=west
        [main.tex]
        [main.pdf]
    ]
    [programming, parent anchor=east, child anchor=west
        [output, parent anchor=east, child anchor=west
            [products.html]
        ]
        [src, parent anchor=east, child anchor=west
            [query\_backend.py]
            [query\_from\_project.py]
            [query\_interactive.py]
            [transform\_backend.py]
            [transform\_from\_project.py]
            [transform\_interactive.py]
            [validate\_backend.py]
            [validate\_from\_project.py]
            [validate\_interactive.py]
        ]
    ]
    [requirements.txt]
]
\end{forest}
\caption{Projektordnerstruktur}
\label{fig:projektordnerstruktur}
\end{figure}

\todo{forest einbinden!!!}

Für dieses Projekt wurden folgende Quellen verwendet:

\begin{itemize}
    \item Moodle-Unterlagen für das Modul Internettechnologien
    \item https://www.digikey.de
    \item https://www.mouser.de
\end{itemize}



\section{Datensatz} \label{sec:datensatz}

Als Thema für den Beispieldatensatz wurden in diesem Projekt elektronische Bauteile eines fiktiven Elektronikshops gewählt. Der vollständige Datensatz dieses Projekts ist in der Datei \textit{products.xml} enthalten. Er umfasst 9 Objekte, davon 3 Widerstände, 2 Spulen, 2 Kondensatoren sowie 2 Dioden. Hintergrund ist, dass die vorhandenen Daten auf einer Produkt-Website dargestellt werden können. Beim Inhalt des Datensatzes wurde sich deshalb auf die dafür wichtigsten Daten konzentriert. Das Root-Element ist \textit{Products}, das alle \textit{Product}-Elemente enthält. Diese können über den Eintrag im \textit{id}-Attribut eindeutig identifiziert werden. Jedes dieser \textit{Product}-Elemente umfasst die Elemente Anzahl, Preis und Hersteller sowie, abhängig vom mit dem \textit{type}-Attribut spezifizierten Bauteil, eine oder zwei bauteilspezifische Datensequenzen. Diese beinhalten die physikalischen Größen des jeweiligen Bauteils, wobei der Wert, die Einheit und die Toleranz angegeben werden. Die Einheit \todo{Einheit??? \% ist keine Einheit} der Toleranz kann mit dem \textit{unit}-Attribut eingestellt werden, ebenso die Einheit des Preises. Die Bezeichnung dieser Datensequenz ist für jedes Bauteil spezifisch. Während die Widerstände, Spulen und Kapazitäten jeweils nur eine spezifische physikalische Größe umfassen, können für Dioden mehrere angegeben werden. Diese konkrete Zuordnung der physikalischen Größen vereinfacht die anschließende Validierung der XML-Datei mit der XSD-Schemadatei.

Das zugehörige Schema befindet sich in \texttt{products.xsd}. Es definiert Struktur, Reihenfolge und Häufigkeit der verwendeten Elemente. Das Schema dient dazu, die Angaben in der XML-Datei auf formale Richtigkeit zu überprüfen. Damit kann sichergestellt werden, dass die geforderten Angaben in der XML-Datei gemacht wurden. Diese Richtigkeit ist für die Transformation in andere Datenformate unerlässlich. Außerdem kann überprüft werden, ob die angegebenen Datentypen korrekt sind. Die erstellte XSD-Datei dieses Projekts ist in \textit{products.xsd} zu finden. Beim Entwurf des XSD-Schemas wurde darauf geachtet, jedes Element über einen eigenen Typ zu kapseln, sodass spätere Änderungen gezielt und unabhängig vorgenommen werden können. Die verwendeten Datentypen wurden bewusst gewählt, um eine valide und konsistente Datenstruktur sicherzustellen. Standardwerte kommen dort zum Einsatz, wo Attribute fehlen, um sinnvolle und einheitliche Einstellungen zu gewährleisten. Feste Werte werden verwendet, um Abweichungen frühzeitig zu erkennen und als Fehler zu kennzeichnen. Darüber hinaus wurde die Datei \textit{products-automatic-generated.xsd} automatisch durch die Dokumentenerstellung mit \textit{EditiX} erzeugt. Diese Datei ist jedoch nicht so präzise wie \textit{products.xsd}.Es können nicht an allen Stellen die gewünschten Datentypen angegeben werden. Außerdem ist es nicht möglich, ein \textit{choice}-Element zu verwenden. Es wird daher empfohlen, zur Validierung der XML-Datei die XSD-Datei \textit{products.xsd} zu verwenden.



\section{Transformationen}
\label{sec:Transformationen}
\subsection{XSLT von XML in HTML}
Um die XML in HTML transformieren zu können, wurde \texttt{products.xslt} erstellt. Die tabellenförmige Ausgabe wurde getrennt für Widerstände, Spulen und Kondensatoren sowie für Dioden vorgenommen, da für erstere jeweils eine physikalische Größe angegeben ist, für letztere zwei physikalische Größen sowie der Untertyp.

Die physikalischen Größen selbst wurden mit einem gemeinsamen Template ausgewertet, da alle einen Wert und eine Einheit sowie einen optionalen Exponenten und eine optionale Toleranz aufweisen. Mit einer \texttt{xsl:when}-Abfrage wurde sichergestellt, dass bei Abwesenheit einer Toleranz dieses Feld mit einem Bindestrich gefüllt wird. Da das Feld für die physikalische Größe in der entsprechenden Tabelle jedoch auch ohne einen explizit vorgegebenen Exponenten korrekt ausgefüllt wird und alle weiteren Angaben in der Tabelle obligatorisch sind, ist dieses Vorgehen nur für die Toleranz notwendig.

Im Allgemeinen wurden die Templates so generisch wie möglich erstellt, um eine hohe Flexibilität für mögliche Veränderungen zu gewährleisten.

\subsection{FOP-Transformation}
Für die FOP-Transformation wurde hauptsächlich die XSLT für den HTML-Output wiederverwendet, da die gleichen Informationen mittels XPath ermittelt wurden. Es wurde lediglich die HTML-Syntax durch FO-Syntax ersetzt, zusätzlich wurde ein Master-Layout definiert.

Der einzige Unterschied besteht in der Behandlung des $\Omega$. Dieses musste im Vergleich zu HTML und zu den anderen Zeichen des Dokuments stets um 0.145\,em nach oben verschoben werden, da es sonst eine halbe Zeile zu tief steht.



\subsection{Vergleich der Transformationen}
Die erste Transformation wandelt eine XML in ein HTML-Dokument, wohingegen die zweite Transformation ein FO erzeugt, das als PDF gerendert werden kann.

Beide Transformationen sind sehr generisch -- mit ihnen kann stets das angestrebte Output-Dokument erzeugt werden, sofern die übergebene XML den in \autoref{sec:datensatz} erläuterten Anforderungen der Schemadatei genügt.

\section{Programmierung}
\label{sec:Programmierung}

Um die geforderte Validierung, Abfrage und Transformation der XML-Datei zu ermöglichen, wurde für dieses Projekt die Programmiersprache \textit{Python} verwendet. Durch das Modul \textit{lxml} ist es möglich, diese Funktionalitäten umzusetzen.



\end{document}

