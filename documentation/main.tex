\documentclass[
paper = a4,
fontsize = 12pt,
numbers=noenddot,
headsepline = true,
footsepline = true,
plainfootsepline = true,
parskip,								        
listof = nottotoc,
bibliography = totoc,
index = totoc,
twoside = false
]{scrartcl}

% -------------------------------------------------
% Pakete: Sprache, Schrift, Layout
% -------------------------------------------------
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} % bei pdflatex
\usepackage{lmodern}

\usepackage{color} 								% Schrift färben
\usepackage{tikz}
\usetikzlibrary{arrows.meta, calc, positioning, shapes.symbols, shapes.misc}

\usepackage{geometry}
\geometry{
    left=3cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}

\usepackage{setspace}
\onehalfspacing

% -------------------------------------------------
% Mathe, Grafiken, Tabellen
% -------------------------------------------------
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage[hidelinks]{hyperref}
\usepackage{forest}

% -------------------------------------------------
% Kopf- und Fußzeilen (KOMA-konform, einheitlich)
% -------------------------------------------------
\usepackage{scrlayer-scrpage}
\clearpairofpagestyles

\usepackage{xcolor}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}

% Automatische Marken für scrartcl: section
\automark{section}

% Linienfarbe
\addtokomafont{headsepline}{\color{mygray}}
\addtokomafont{footsepline}{\color{mygray}}

% Kopfzeile: rechts Abschnittsname
\ohead{\color{mygray}\leftmark}

% Fußzeile: Seitenzahl mittig
\cfoot{\color{mygray}\pagemark}

% Auch für plain-Seiten (TOC etc.) erzwingen
\pagestyle{scrheadings}

\setlength{\footskip}{1.2cm}


% -------------------------------------------------
% Titelinformationen
% -------------------------------------------------
\title{
    \textbf{\\[2cm] Dokumentation zum XML-Projekt im Master-Modul Internettechnologie}     \vspace{1cm}
}

\author{
    \Large{\textbf{Lennart Mende}} \\
    \Large{\textbf{Richard Mende}} \\[2cm]
    \large{HTWK Leipzig} \\
    \large{Wintersemester 2025/26} \\
    \large{Prof. Dr.-Ing. Andreas Pretschner}
}

\date{\vspace{3cm}\large{\today}}

% =================================================
\begin{document}
% =================================================

% -----------------------------
% Titelseite
% -----------------------------
\maketitle

\thispagestyle{empty}

\newpage

% -----------------------------
% Inhaltsverzeichnis
% -----------------------------
\tableofcontents

\thispagestyle{empty}
% \vspace{2cm}

% -----------------------------
% Abbildungs- und Tabellenverzeichnis (optional)
% -----------------------------
% \listoffigures

% \vspace{2cm}

% \listoftables
\newpage
\setcounter{page}{1}

% =================================================
% Hauptteil
% =================================================

\section{Projekübersicht}

\subsection{Zielstellung}

Als Grundlage dieses Projekts dient das Anlegen eines XML-Datensatzes, der aus mehreren Objekten besteht. Diese sollen jeweils mindestens ein Attribut sowie eine Datensequenz bestehen. Auf Basis dieses Datensatzes wird eine XSD-Schemadatei erstellt, sodass die XML-Datei validiert werden kann. Dabei wird überprüft, ob die XML-Datei der definierten Struktur entspricht und alle erforderlichen Angaben enthalten sind. Zusätzlich wird eine XSD-Schemadatei mithilfe der in \textit{EditiX} integrierten automatischen Dokumenterstellung generiert.

Der zweite Teil des Projekts befasst sich mit der Transformation der XML-Datei in zwei unterschiedliche Ausganbeformate. Zunächst sollen die Daten aus der XML-Datei in Form einer HTML-Seite dargestellt werden, wofür eine XSLT-Transformationsdatei erstellt werden muss. Darüber hinaus erfolgt die FOP-Transformation in eine PDF erfolgen, wodurch eine PDF generiert wird. Eine schematische Übersicht dieser Transformationen zeigt \autoref{fig:files}.

Der dritte Aufgabenteil beschäftigt sich mit der XML-Programmierung. Dabei soll eine Applikation erstellt werden, welche die Validierung, Abfrage und Transformation der XML-Datei ermöglicht.

\enlargethispage{1\baselineskip}

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth, thick]

% ---------------- Parameter ----------------
\def\filewidth{1.8}
\def\fileheight{2.7}
\def\fold{0.5}
\def\scale{1}

\def\dx{3.3}     % horizontaler Abstand
\def\dy{2}       % vertikaler Versatz der Pfade

% ---------------- XML (Mittellinie) ----------------
\node (xml) at (0,0) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XML};
\end{tikzpicture}
};

% ---------------- XSD ----------------
\node (xsd) [below=of xml] {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XSD};
\end{tikzpicture}
};

\draw[<->] (xsd) -- (xml);

% ---------------- Unterer Pfad: XSL → FO → PDF ----------------
\node (xsl) at (\dx,-\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XSL};
\end{tikzpicture}
};

\node (fo) at (2*\dx,-\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\node at (\filewidth/2,\fileheight/2) {FO};
\end{tikzpicture}
};

\node (pdf) at (3*\dx,-\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\node at (\filewidth/2,\fileheight/2) {PDF};
\end{tikzpicture}
};

% ---------------- Oberer Pfad: XSLT → HTML ----------------
\node (xslt) at (\dx,\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XSLT};
\end{tikzpicture}
};

\node (html) at (3*\dx,\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\node at (\filewidth/2,\fileheight/2) {HTML};
\end{tikzpicture}
};

% ---------------- Pfeile: horizontale Aufteilung ----------------

\draw[->] (xml.north east) -- (xslt.west);
\draw[->] (xml.south east) -- (xsl.west);

\draw[->] (xsl) -- (fo);
\draw[->] (fo) -- (pdf);

\draw[->] (xslt) -- (html);

\end{tikzpicture}
\caption{Übersicht der Dokumenttypen und Transformationspfade}
\label{fig:files}
\end{figure}



\subsection{Projektorganisation}

Zur strukturierten Umsetzung des Projekts sowie zur Sicherstellung einer nachvollziehbaren Versionsverwaltung wurde ein öffentlich zugängliches \textit{GitHub-Repository} unter \url{https://github.com/rimen13/Projekt_Internettechnologie} eingerichtet. Die Gliederung der Projektdateien ergibt sich folgendermaßen:

{\footnotesize
\begin{verbatim}
project/
|-- assets/
|   |-- src/
|   |   |-- products.xml
|   |   |-- products.xsd
|   |   |-- products-automatic-generated.xsd
|   |   |-- products-to-html.xslt
|   |   |-- products-to-pdf.xsl
|   |-- output/
|       |-- products.html
|       |-- products.fo
|       |-- products.pdf
|-- documentation/
|   |-- documentation.pdf
|-- programming/
    |-- src/
    |   |-- query_backend.py
    |   |-- query_from_project.py
    |   |-- query_interactive.py
    |   |-- validate_backend.py
    |   |-- validate_from_project.py
    |   |-- validate_interactive.py
    |   |-- transform_backend.py
    |   |-- transform_from_project.py
    |   |-- transform_interactive.py
    |-- output/
    |   |-- products.html
    |-- requirements.txt
\end{verbatim}
}

Als Entwicklungswerkzeuge kamen der XML-Editor \textit{EditiX} zur Erstellung und Dokumentation der XML- und XSD-Dateien sowie \textit{Visual Studio Code} als integrierte Entwicklungsumgebung zur Umsetzung der XML-Programmierung zum Einsatz. Die inhaltliche Ausarbeitung orientiert sich an den in Moodle bereitgestellten Unterlagen zum Modul \textit{Internettechnologie}. Die in der XML-Datei verwendeten Preise und Stückzahlen der elektronischen Bauteile basieren auf den Angaben der beiden Websiten \url{https://www.digikey.de} und \url{https://www.mouser.de}.

\begin{figure}[H]
\centering
\begin{forest}
for tree={
    font=\ttfamily,
    grow'=0,
    child anchor=west,
    parent anchor=south,
    anchor=west,
    align=left,
    tier/.option=level,
    inner xsep=1.5pt,
    %scale=0.4,
    edge path={
        \noexpand\path [draw, \forestoption{edge}]
        (!u.parent anchor) -- +(5pt,0) |- (.child anchor)\forestoption{edge label};
    },
}
[project, parent anchor=east, child anchor=west
    [assets, parent anchor=east, child anchor=west
        [output, parent anchor=east, child anchor=west
            [products.fo]
            [products.html]
            [products.pdf]
        ]
        [src, parent anchor=east, child anchor=west
            [products-automatic-generated.xsd]
            [products-to-html.xslt]
            [products-to-pdf.xsl]
            [products.xml]
            [products.xsd]
        ]
    ]
    [documentation, parent anchor=east, child anchor=west
        [documentation.pdf]
    ]
    [programming, parent anchor=east, child anchor=west
        [output, parent anchor=east, child anchor=west
            [products.html]
        ]
        [src, parent anchor=east, child anchor=west
            [query\_backend.py]
            [query\_from\_project.py]
            [query\_interactive.py]
            [transform\_backend.py]
            [transform\_from\_project.py]
            [transform\_interactive.py]
            [validate\_backend.py]
            [validate\_from\_project.py]
            [validate\_interactive.py]
        ]
        [requirements.txt, parent anchor=east, child anchor=west]
    ]
]
\end{forest}
\caption{Projektordnerstruktur}
\label{fig:projektordnerstruktur}
\end{figure}





\section{Datensatz} \label{sec:datensatz}

\subsection{XML-Datei}

Als Beispieldatensatz für dieses Projekt wurde ein Katalog elektronischer Bauteile eines fiktiven Elektronikshops modelliert. Der vollständige Datensatz ist in der Datei \textit{products.xml} abgelegt und umfasst insgesamt neun Produkte, darunter drei Widerstände, zwei Spulen, zwei Kondensatoren sowie zwei Dioden. Das Root-Element \textit{products} kapselt alle enthaltenen \textit{product}-Elemente. Jedes \textit{product}-Element repräsentiert ein einzelnes Bauteil und ist über das Attribut \textit{id} eindeutig identifizierbar. Zusätzlich wird über das Attribut \textit{type} der grundlegende Bauteiltyp spezifiziert, bei Dioden optional erweitert durch das Attribut \textit{subtype}. Unabhängig vom konkreten Bauteiltyp enthalten alle \textit{product}-Elemente eine einheitliche Menge an Kindelementen zur Beschreibung allgemeiner Produkteigenschaften. Diese sind \textit{amount}, \textit{price} und \textit{manufacturer}. Der Preis kann über ein \textit{unit}-Attribut weiter typisiert werden, wodurch unterschiedliche Währungseinheiten realisierbar sind.

Ergänzend zu diesen allgemeinen Angaben besitzt jedes Produkt eine oder mehrere bauteilspezifische Datensequenzen, welche die relevanten physikalischen Kenngrößen modellieren. Die Bezeichnung dieser Sequenzen ist vom jeweiligen Bauteiltyp abhängig, \textit{resistance} für Widerstände, \textit{inductance} für Spulen oder \textit{capacitance} für Kondensatoren. Für Dioden mehrere Kenngrößen angegeben werden (Durchlassspannung \textit{forwardVoltage} sowie Sperrspannung \textit{reverseVoltage}). Diese Elemente enthalten jeweils eine strukturierte Beschreibung des Zahlenwertes, bestehend aus Mantisse (\textit{value}), Exponent (\textit{exponent}), Einheit (\textit{unit}) sowie optional einer Toleranzangabe. Der Exponent ist hierbei auf Werte beschränkt, die durch 3 teilbar sind, da nur diese später in physikalische Vorsilben wie \textmu{}, m, k etc. umgerechnet werden können. Die Toleranz kann über ein \textit{unit}-Attribut in Prozent angegeben werden. Diese explizite Zuordnung der physikalischen Größen zu den jeweiligen Bauteiltypen erleichtert die formale Beschreibung des Datenmodells und bildet eine geeignete Grundlage für die spätere Validierung des XML-Dokuments mithilfe einer XSD-Schemadatei.



\textcolor{red}{alter Text:}

Als Thema für den Beispieldatensatz wurden in diesem Projekt elektronische Bauteile eines fiktiven Elektronikshops gewählt. Der vollständige Datensatz dieses Projekts ist in der Datei \textit{products.xml} enthalten. Er umfasst 9 Objekte, davon 3 Widerstände, 2 Spulen, 2 Kondensatoren sowie 2 Dioden. Hintergrund ist, dass die vorhandenen Daten auf einer Produkt-Website dargestellt werden können. Beim Inhalt des Datensatzes wurde sich deshalb auf die dafür wichtigsten Daten konzentriert. Das Root-Element ist \textit{Products}, das alle \textit{Product}-Elemente enthält. Diese können über den Eintrag im \textit{id}-Attribut eindeutig identifiziert werden. Jedes dieser \textit{Product}-Elemente umfasst die Elemente Anzahl, Preis und Hersteller sowie, abhängig vom mit dem \textit{type}-Attribut spezifizierten Bauteil, eine oder zwei bauteilspezifische Datensequenzen. Diese beinhalten die physikalischen Größen des jeweiligen Bauteils, wobei der Wert, die Einheit und die Toleranz angegeben werden. Sie kann mithilfe des \textit{unit}-Attributs relativ (bspw. mit \%) oder absolut eingestellt werden. Die Einheit des Preises kann ebenfalls mit einem \textit{unit}-Attribut definiert werden. Die Bezeichnung dieser Datensequenz ist für jedes Bauteil spezifisch. Während die Widerstände, Spulen und Kapazitäten jeweils nur eine spezifische physikalische Größe umfassen, können für Dioden mehrere angegeben werden. Diese konkrete Zuordnung der physikalischen Größen vereinfacht die anschließende Validierung der XML-Datei mit der XSD-Schemadatei.



\subsection{XSD-Schemadatei}

Zur formalen Beschreibung des XML-Datenmodells dient die XSD-Schemadatei \textit{products.xsd}. Sie definiert die Struktur, Reihenfolge und erlaubte Häufigkeit der enthaltenen Elemente und stellt damit sicher, dass alle Angaben in der XML-Datei \textit{products.xml} valide und konsistent sind. Insgesamt gewährleistet die XSD-Schemadatei eine eindeutige Definition des Datenmodells, unterstützt die Validierung von Datentypen, Elementreihenfolgen und Attributen. Das Root-Element \textit{products} kapselt die \textit{product}-Elemente, deren Anzahl mindestens 1 betragen muss. Jedes \textit{product}-Element verweist auf ein oder mehrere bauteilspezifische Kindelemente, die über einen \textit{choice}-Konstrukt modelliert sind. Dadurch werden die zulässigen Kombinationen physikalischer Größen wie \textit{resistance}, \textit{inductance}, \textit{capacitance}, \textit{forwardVoltage} und \textit{reverseVoltage} zum jeweiligen Bauteil erlaubt.

Alle Produkte besitzen allgemeine Attribute wie \textit{id}, \textit{type} und optional \textit{subtype}, die über eine \textit{attributeGroup} zentral verwaltet werden. Die bauteilspezifischen Elemente nutzen jeweils einen eigenen \textit{complexType}, der die Mantisse (\textit{value}), den Exponenten (\textit{exponent}), die Einheit (\textit{unit}) und optional eine Toleranz (\textit{tolerance}) kapselt. Die Typisierung der Elemente erfolgt über primitive Datentypen wie \textit{float}, \textit{short} oder \textit{string}, während für Attribute Standardwerte und feste Werte genutzt werden, um Konsistenz zu gewährleisten und Abweichungen frühzeitig als Fehler zu erkennen. Für die Preisangaben wurde ein spezieller \textit{PriceType} implementiert, der den Wert und die Einheit kapselt.

Die automatisch durch \textit{EditiX} erzeugte Datei \textit{products-automatic-generated.xsd} kann ebenfalls zur Dokumentation herangezogen werden, enthält jedoch nicht die gleichen präzisen Typdefinitionen, erlaubt keine \textit{choice}-Strukturen und ist daher für die Validierung der XML-Datei nur eingeschränkt geeignet. Es wird daher empfohlen, zur Validierung der XML-Datei die XSD-Datei \textit{products.xsd} zu verwenden.



\textcolor{red}{alter Text:}

Das zugehörige Schema befindet sich in \texttt{products.xsd}. Es definiert Struktur, Reihenfolge und Häufigkeit der verwendeten Elemente. Das Schema dient dazu, die Angaben in der XML-Datei auf formale Richtigkeit zu überprüfen. Damit kann sichergestellt werden, dass die geforderten Angaben in der XML-Datei gemacht wurden. Diese Richtigkeit ist für die Transformation in andere Datenformate unerlässlich. Außerdem kann überprüft werden, ob die angegebenen Datentypen korrekt sind. Die erstellte XSD-Datei dieses Projekts ist in \textit{products.xsd} zu finden. Beim Entwurf des XSD-Schemas wurde darauf geachtet, jedes Element über einen eigenen Typ zu kapseln, sodass spätere Änderungen gezielt und unabhängig vorgenommen werden können. Die verwendeten Datentypen wurden bewusst gewählt, um eine valide und konsistente Datenstruktur sicherzustellen. Standardwerte kommen dort zum Einsatz, wo Attribute fehlen, um sinnvolle und einheitliche Einstellungen zu gewährleisten. Feste Werte werden verwendet, um Abweichungen frühzeitig zu erkennen und als Fehler zu kennzeichnen. Darüber hinaus wurde die Datei \textit{products-automatic-generated.xsd} automatisch durch die Dokumentenerstellung mit \textit{EditiX} erzeugt. Diese Datei ist jedoch nicht so präzise wie \textit{products.xsd}. Es können nicht an allen Stellen die gewünschten Datentypen angegeben werden. Außerdem ist es nicht möglich, ein \textit{choice}-Element zu verwenden. Es wird daher empfohlen, zur Validierung der XML-Datei die XSD-Datei \textit{products.xsd} zu verwenden.




\section{Transformationen von XML-Daten} \label{sec:Transformationen}

In diesem Kapitel wird die Umsetzung der Transformationen der XML-Daten in verschiedene Ausgabeformate beschrieben. Es werden die verwendeten XSLT-Templates zur Erzeugung von HTML sowie die XSL-FO-Transformation für PDF-Dokumente erläutert. Die hier beschriebenen Verfahren basieren auf der XML-Struktur und den in Kapitel \ref{sec:datensatz} definierten Datentypen und Elementen.

\subsection{XSLT-Transformation von XML zu HTML}

Für die Darstellung der Produktdaten in tabellarischer Form wurde die Datei \texttt{products.xslt} erstellt. Die Tabellen sind nach Bauteiltypen getrennt: Widerstände, Spulen und Kondensatoren besitzen jeweils eine physikalische Größe, während Dioden zwei Kenngrößen (Forward Voltage, Reverse Voltage) sowie den Untertyp enthalten.  

Die Templates greifen über XPath-Ausdrücke auf die Kindelemente der XML-Daten zu und extrahieren die entsprechenden Werte. Jede physikalische Kenngröße wird über ein gemeinsames Template ausgewertet, das Mantisse, Exponent, Einheit und optional vorhandene Toleranz verarbeitet. Die Exponenten werden dabei nach physikalischen Vorsilben interpretiert (p, n, \textmu, m, k, M). Fehlen optionale Werte wie die Toleranz, wird ein Platzhalter \texttt{-} in die Tabelle eingesetzt, um eine konsistente tabellarische Darstellung zu gewährleisten.

Die Tabellenüberschriften werden über \texttt{<th>}-Elemente generiert, wobei die Reihenfolge der Zellen der XML-Struktur entspricht. Die Templates sind modulartig implementiert, um spätere Anpassungen oder neue Bauteiltypen einfach integrieren zu können.  

Beispielsweise wird die Einheit des Widerstandes ($\Omega$) korrekt zusammen mit dem Exponenten angezeigt, sodass bei einer Umrechnung in physikalische Vorsilben die Lesbarkeit erhalten bleibt. Die Wiederverwendbarkeit der Templates erlaubt die einfache Anpassung für unterschiedliche Layouts oder neue Produktdaten.

\subsection{XSL-FO-Transformation zu PDF}

Für die FOP-Transformation wurde die XSLT-Logik der HTML-Ausgabe größtenteils wiederverwendet. Die Informationen werden über XPath auf die XML-Daten zugregriffen, die HTML-Syntax durch XSL-FO ersetzt und ein Master-Layout definiert, das Seitenränder, Schriftart und -größe festlegt.

Jedes Bauteil wird als Zeile in einer \texttt{fo:table} ausgegeben, wobei Tabellenüberschriften über \texttt{fo:table-header} und Zellen über \texttt{fo:table-cell} definiert werden. Optionale Werte, wie Toleranzen, werden ebenfalls mit Platzhalterwerten angezeigt, wenn diese in der XML nicht vorhanden sind.  

Eine Besonderheit der FO-Transformation betrifft das Omega-Zeichen für Widerstände. Da dieses Zeichen sonst eine halbe Zeile zu tief angezeigt wird, wird es mittels \texttt{baseline-shift} vertikal korrekt positioniert. Alle anderen physikalischen Einheiten werden standardmäßig inline ausgegeben.

Die Exponenten der physikalischen Größen werden in Vorsilben umgesetzt (p, n, \textmu, m, k, M). Es wird dabei sichergestellt, dass nur Exponenten verwendet werden, die durch 3 teilbar sind, um eine korrekte Zuordnung zu den SI-Vorsilben zu gewährleisten. Dies erleichtert die konsistente Darstellung der physikalischen Größen sowohl in HTML als auch in PDF.

\subsection{Flexibilität und Wiederverwendbarkeit}

Die Templates sind so generisch implementiert, dass Änderungen der XML-Struktur, neue Bauteiltypen oder zusätzliche Kenngrößen leicht integriert werden können. Die Verwendung von XPath-Ausdrücken in Verbindung mit \texttt{<xsl:apply-templates>} ermöglicht die modulare Verarbeitung aller relevanten Elemente.  

Durch die Trennung von Layout (HTML vs. FO) und Datenlogik (XPath, Templates) wird eine hohe Wartbarkeit erreicht. Anpassungen am visuellen Erscheinungsbild, an den Tabellenlayouts oder an der Darstellung von physikalischen Größen können ohne Änderungen an der Datenstruktur umgesetzt werden.

Die Transformationen dienen dazu, die im Kapitel \ref{sec:datensatz} definierten XML-Daten in unterschiedliche Ausgabeformate zu überführen. Die XSLT-Templates erlauben die Erzeugung von HTML-Tabellen, während die XSL-FO-Templates die Darstellung in PDF-Dateien ermöglichen. Optional vorhandene Werte werden durch Platzhalter ersetzt, Exponenten werden in physikalische Vorsilben umgesetzt, und Sonderzeichen wie $\Omega$ werden korrekt positioniert. Die modulare, XPath-basierte Implementierung sorgt für Flexibilität, Wiederverwendbarkeit und einfache Wartbarkeit der Transformationen.





\textcolor{red}{alter Text:}

\section{Transformationen} %\label{sec:Transformationen}

\subsection{XSLT von XML in HTML}

Um die XML in HTML transformieren zu können, wurde \texttt{products.xslt} erstellt. Die tabellenförmige Ausgabe wurde getrennt für Widerstände, Spulen und Kondensatoren sowie für Dioden vorgenommen, da für erstere jeweils eine physikalische Größe angegeben ist, für letztere zwei physikalische Größen sowie der Untertyp.

Die physikalischen Größen selbst wurden mit einem gemeinsamen Template ausgewertet, da alle einen Wert und eine Einheit sowie einen optionalen Exponenten und eine optionale Toleranz aufweisen. Mit einer \texttt{xsl:when}-Abfrage wurde sichergestellt, dass bei Abwesenheit einer Toleranz dieses Feld mit einem Bindestrich gefüllt wird. Da das Feld für die physikalische Größe in der entsprechenden Tabelle jedoch auch ohne einen explizit vorgegebenen Exponenten korrekt ausgefüllt wird und alle weiteren Angaben in der Tabelle obligatorisch sind, ist dieses Vorgehen nur für die Toleranz notwendig.

Im Allgemeinen wurden die Templates so generisch wie möglich erstellt, um eine hohe Flexibilität für mögliche Veränderungen zu gewährleisten.

\subsection{FOP-Transformation}

Für die FOP-Transformation wurde hauptsächlich die XSLT für den HTML-Output wiederverwendet, da die gleichen Informationen mittels XPath ermittelt wurden. Es wurde lediglich die HTML-Syntax durch FO-Syntax ersetzt, zusätzlich wurde ein Master-Layout definiert.

Der einzige Unterschied besteht in der Behandlung des $\Omega$. Dieses musste im Vergleich zu HTML und zu den anderen Zeichen des Dokuments stets um 0.145\,em nach oben verschoben werden, da es sonst eine halbe Zeile zu tief steht.



%\subsection{Vergleich der Transformationen}

% Die erste Transformation wandelt eine XML in ein HTML-Dokument, wohingegen die zweite Transformation ein FO erzeugt, das als PDF gerendert werden kann.

Die beiden durchgeführten Transformationen sind sehr generisch -- mit ihnen kann stets das angestrebte Output-Dokument erzeugt werden, sofern die übergebene XML den in \autoref{sec:datensatz} erläuterten Anforderungen der Schemadatei genügt.



\section{Programmierung} \label{sec:Programmierung}

\subsection{Grundlegende Informationen}

Durch die XML-Programmierung sollen folgende Funktionalitäten implementiert werden:

\begin{enumerate}
    \item Validierung eines XML-Dokuments gegen ein XSD-Schema
    \item Abfrage von Informationen aus einem XML-Dokument
    \item Transformation eines XML-Dokuments in eine HTML-Website
\end{enumerate}

Zur Umsetzung dieser Funktionalitäten wird im Rahmen dieses Projekts die Programmiersprache \textit{Python} verwendet. Um das die in den folgenden Kapiteln beschriebenen Befehle in der Kommandozeile ausführen zu können, muss \textit{Python} von der offiziellen Website https://www.python.org unter dem Reiter \textit{Downloads} installiert werden. Für dieses Projekt wurde Version 3.12.8 genutzt. Außerdem müssen die beiden Module \textit{lxml} und \textit{tkinter} installiert werden.

Durch das Modul \textit{lxml} ist es möglich, diese Funktionalitäten umzusetzen.



Damit die Befehle über die Kommandozeile aufgerufen werden können, muss zunächst ein lokaler Python Download erfolgen.

HIER MUSS ICH ES MAL MIT MEINEM EIGENEN LINUX SYSTEM PROBIEREN!




Für alle 3 Teilaufgaben existieren 3 getrennte Python-Dateien:

\begin{enumerate}
    \item Backend-Datei (\texttt{*\_backend.py}): enthält ausschließlich die Logik der jeweiligen Aufgabe und können nicht direkt ausgeführt werden
    \item Projektmodus-Datei (\texttt{*\_from\_project.py}): führt die jeweilige Aufgabe mit den im Projekt erarbeiteten Dateien aus
    \item Interaktiv-Datei (\texttt{*\_interactive.py}): ermöglicht die Auswahl beliebiger Dateien und führt die jeweilige Aufgabe für diese durch
\end{enumerate}

Die jeweiligen Dateien enthalten den beschriebenen Code, der ausführlich kommentiert ist. Die Dateien können ausgeführt werden, indem man zunächst die virtuelle Umgebung aktiviert und in der Kommandizeile in das Verzeichnis \texttt{programming/src} wechselt und den Befehl \texttt{python\ desired\_file.py} ausführt. Dabei ist \texttt{desired\_file.py} ein Platzhalter für den eigentlichen Dateinamen, der an dieser Stelle natürlich eingesetzt werden muss.



\subsection{Abfrage}

Bei der Abfrage werden gezielt Informationen aus einem XML-Dokument extrahiert, indem XPath verwendet wird. Hierbei werden 3 verschiedene Abfragen durchgeführt:

\begin{enumerate}
    \item Welche Produkt-IDs gibt es?
    \item Wie heißen die Hersteller? (Hierbei sollen mehrfach aufgeführte Hersteller nur einmal aufgeführt werden.)
    \item Was ist die Gesamtanzahl aller Widerstände im Lager?
\end{enumerate}

Führt man die Datei \texttt{query\_from\_project.py} für den Projektmodus aus, dann wird in der Kommandozeile folgendes ausgegeben:

\begin{verbatim}
Query 1: Retrieve all product IDs.
Result: ['R001', 'R002', 'R003', 'L001', 'L002', 'C001', 'C002', 
        'D001', 'D002']

Query 2: Retrieve unique manufacturer names.
Result: ['Diodes Incorporated', 'Micro Commercial Components', 
        'Murata Power Solutions', 'Samsung Electro-Mechanics', 
        'Stackpole Electronics', 'Taiyo Yuden']

Query 3: Calculate the total number of resistors in stock.
Result: 864907
\end{verbatim}

Möchte man die interaktive Abfrage durchführen, kann man über die Datei \texttt{query\_from\_project.py} eine XML-Datei aus dem Datei-Explorer auswählen. Anschließend wird zunächst überprüft, ob die angegebene Datei das vorgegebene XSD-Schema erfüllt. Ist dies nicht der Fall, können die Abfragen nicht durchgeführt werden und es wird eine Fehlermeldung ausgegeben. Ist die XML-Datei gültig, werden ebenfalls die 3 Abfragen getätigt und die Ergebnisse ausgegeben.



\subsection{Validierung}

Um eine XML-Datei gegen ein XSD-Schema validieren zu können, kommen die Dateien \texttt{validate\_from\_project.py} und \texttt{validate\_interactive.py} zur Anwendung. Dabei kann in ersterem Fall die XML-Datei gegen die XSD-Datei aus dem gegebenen Projekt validiert werden. Für die zweite Datei ist die Auswahl einer beliebigen XML- und XSD-Datei im Datei-Explorer möglich. Die Ausgabe in der Kommandozeile für eine gültige oder nicht gültige XML-Datei lautet folgendermaßen (kommt auch mit automatisch generierter XSD raus):

\begin{verbatim}
VALIDATION RESULT: products.xml is valid according to products.xsd

VALIDATION RESULT: products.xml is NOT valid according to products.xsd
\end{verbatim}



\subsection{Transformation}

Die Transformation erfolgt über die Dateien \texttt{transfrom\_from\_project.py} und \texttt{transform\_interactive.py}. Dabei wird entweder die XML- und XSLT-Datei des gegebenen Projekts verwendet oder im interaktiven Modus werden diese beiden Dateitypen vom Anwender übergeben. Anschließend wird die Transformation in eine HTML-Datei durchgeführt und in den \textit{output}-Ordner (in \textit{programming}) gelegt, sodass sich der Anwender die entstehende HTML-Website anschauen kann. Im interaktiven Modus kann sich der Anwender den Zielordner selsbt aussuchen. In der Kommandozeile kommt der Hinweis:

\begin{verbatim}
HTML generated: products.html
\end{verbatim}

Im Unterordner \textit{programming/output} befindet sich bereits die HTML-Datei, die durch die durchgeführte Transformation für die im Projekt gegebenen Dokumente entstanden ist.

\end{document}
