\documentclass[
paper = a4,
fontsize = 12pt,
numbers=noenddot,
headsepline = true,
footsepline = true,
plainfootsepline = true,
parskip,								        
listof = nottotoc,
bibliography = totoc,
index = totoc,
twoside = false
]{scrartcl}



\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}

\usepackage{color} 
\usepackage{tikz}
\usetikzlibrary{arrows.meta, calc, positioning, shapes.symbols, shapes.misc}

\usepackage{geometry}
\geometry{
    left=3cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}

\usepackage{setspace}
\onehalfspacing

\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage[hidelinks]{hyperref}
\usepackage{scrlayer-scrpage}
\clearpairofpagestyles

\usepackage{xcolor}
\usepackage{longtable}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}

% Automatische Marken für scrartcl: section
\automark{section}

% Linienfarbe
\addtokomafont{headsepline}{\color{mygray}}
\addtokomafont{footsepline}{\color{mygray}}

% Kopfzeile: rechts Abschnittsname
\ohead{\color{mygray}\leftmark}

% Fußzeile: Seitenzahl mittig
\cfoot{\color{mygray}\pagemark}

% Auch für plain-Seiten (TOC etc.) erzwingen
\pagestyle{scrheadings}

\setlength{\footskip}{1.2cm}



% Titelinformationen
\title{
    \textbf{\\[2cm] Dokumentation zum XML-Projekt im Master-Modul Internettechnologie}     \vspace{1cm}
}

\author{
    \Large{\textbf{Lennart Mende}} \\
    \Large{\textbf{Richard Mende}} \\[2cm]
    \large{HTWK Leipzig} \\
    \large{Wintersemester 2025/26} \\
    \large{Prof. Dr.-Ing. Andreas Pretschner}
}

\date{\vspace{3cm}\large{\today}}


\begin{document}



% Titelseite
\maketitle

\thispagestyle{empty}

\newpage


% Inhaltsverzeichnis
\tableofcontents

\thispagestyle{empty}

\vspace{2cm}

% Abbildungsverzeichnis

\begin{longtable}[l]{@{}ll@{}}
\textbf{Abkürzung} & \textbf{Bedeutung} \\[1.2ex]

FO &  \\
HMTL &  \\
PDF &  \\
XML &  \\
XSD &  \\
XSL &  \\
XSLT &  \\

\end{longtable}

\newpage
\setcounter{page}{1}

% =================================================
% Hauptteil
% =================================================

\section{Projekübersicht}





\subsection{Zielstellung}

Als Grundlage dieses Projekts dient das Anlegen eines XML-Datensatzes, der aus mehreren Objekten besteht. Diese sollen jeweils mindestens ein Attribut sowie eine Datensequenz enthalten. Auf Basis dieses Datensatzes wird eine XSD-Datei erstellt, sodass die XML-Datei validiert werden kann. Dabei wird überprüft, ob die XML-Datei der definierten Struktur entspricht und alle erforderlichen Angaben enthalten sind. Zusätzlich wird eine XSD-Datei mithilfe der in \textit{EditiX} integrierten automatischen Dokumenterstellung generiert.

Der zweite Teil des Projekts befasst sich mit der Transformation der XML-Datei in zwei unterschiedliche Ausgabeformate. Zunächst sollen die Daten aus der XML-Datei in Form einer HTML-Seite dargestellt werden, wofür eine XSLT-Transformationsdatei erstellt werden muss. Darüber hinaus erfolgt die FOP-Transformation, sodass aus der XML-Datei eine PDF-Datei generiert wird. Eine schematische Übersicht dieser Transformationen zeigt \autoref{fig:files}.

Der dritte Aufgabenteil beschäftigt sich mit der XML-Programmierung. Dabei soll eine Applikation erstellt werden, welche die Validierung, Abfrage und Transformation der XML-Datei ermöglicht.

\enlargethispage{1\baselineskip}

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth, thick]

% ---------------- Parameter ----------------
\def\filewidth{1.8}
\def\fileheight{2.7}
\def\fold{0.5}
\def\scale{1}

\def\dx{3.3}     % horizontaler Abstand
\def\dy{2}       % vertikaler Versatz der Pfade

% ---------------- XML (Mittellinie) ----------------
\node (xml) at (0,0) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XML};
\end{tikzpicture}
};

% ---------------- XSD ----------------
\node (xsd) [below=of xml] {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XSD};
\end{tikzpicture}
};

\draw[<->] (xsd) -- (xml);

% ---------------- Unterer Pfad: XSL → FO → PDF ----------------
\node (xsl) at (\dx,-\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XSL};
\end{tikzpicture}
};

\node (fo) at (2*\dx,-\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\node at (\filewidth/2,\fileheight/2) {FO};
\end{tikzpicture}
};

\node (pdf) at (3*\dx,-\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\node at (\filewidth/2,\fileheight/2) {PDF};
\end{tikzpicture}
};

% ---------------- Oberer Pfad: XSLT → HTML ----------------
\node (xslt) at (\dx,\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XSLT};
\end{tikzpicture}
};

\node (html) at (3*\dx,\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\node at (\filewidth/2,\fileheight/2) {HTML};
\end{tikzpicture}
};

% ---------------- Pfeile: horizontale Aufteilung ----------------

\draw[->] (xml.north east) -- (xslt.west);
\draw[->] (xml.south east) -- (xsl.west);

\draw[->] (xsl) -- (fo);
\draw[->] (fo) -- (pdf);

\draw[->] (xslt) -- (html);

\end{tikzpicture}
\caption{Übersicht der Dokumenttypen und Transformationspfade}
\label{fig:files}
\end{figure}



\subsection{Projektorganisation}

Zur strukturierten Umsetzung des Projekts sowie zur Sicherstellung einer nachvollziehbaren Versionsverwaltung wurde ein öffentlich zugängliches \textit{GitHub-Repository} unter \url{https://github.com/rimen13/Projekt_Internettechnologie} eingerichtet. Die Gliederung der Projektdateien ergibt sich folgendermaßen:

\vspace{-5mm}
{\footnotesize
\begin{verbatim}
project/
|-- assets/
|   |-- src/
|   |   |-- products.xml
|   |   |-- products.xsd
|   |   |-- products-automatic-generated.xsd
|   |   |-- products-to-html.xslt
|   |   |-- products-to-pdf.xsl
|   |-- output/
|       |-- products.html
|       |-- products.fo
|       |-- products.pdf
|-- documentation/
|   |-- documentation.pdf
|-- programming/
    |-- src/
    |   |-- query_backend.py
    |   |-- query_from_project.py
    |   |-- query_interactive.py
    |   |-- validate_backend.py
    |   |-- validate_from_project.py
    |   |-- validate_interactive.py
    |   |-- transform_backend.py
    |   |-- transform_from_project.py
    |   |-- transform_interactive.py
    |-- output/
    |   |-- products.html
    |-- requirements.txt
\end{verbatim}
}

Als Entwicklungswerkzeuge kamen der XML-Editor \textit{EditiX} zur Erstellung der Dateien im Ordner \texttt{assets} sowie \textit{Visual Studio Code} als integrierte Entwicklungsumgebung zur Umsetzung der XML-Programmierung zum Einsatz. Die inhaltliche Ausarbeitung orientiert sich an den Modul-Unterlagen auf Moodle. Die in der XML-Datei verwendeten Preise und Stückzahlen der elektronischen Bauteile basieren auf den Angaben der Websiten \url{https://www.digikey.de} und \url{https://www.mouser.de}. Als Unterstützung beim Sprachstil der Dokumentation, der FO-Syntax und der Programmierung wurde ChatGPT als Unterstützung verwendet.





\section{Datensatz} \label{sec:datensatz}

\subsection{XML-Datei}

Als Beispieldatensatz für dieses Projekt wurde ein Katalog elektronischer Bauteile eines fiktiven Elektronikshops modelliert. Der vollständige Datensatz ist in der Datei \texttt{products.xml} abgelegt und umfasst insgesamt 9 unterschiedliche Bauteile (3 Widerstände, 2 Spulen, 2 Kondensatoren und 2 Dioden). Das XML-Dokument besitzt das Root-Element \textit{products}, unter dem alle \textit{product}-Elemente zusammengefasst sind. Jedes \textit{product}-Element repräsentiert ein einzelnes Bauteil und stellt damit ein Objekt des Datensatzes dar, welches über das Attribut \textit{id} eindeutig zu identifizieren ist. Zusätzlich wird über das Attribut \textit{type} der grundlegende Bauteiltyp spezifiziert, bei Dioden erweitert durch das Attribut \textit{subtype}. Unabhängig vom konkreten Bauteiltyp enthalten alle \textit{product}-Elemente eine einheitliche Menge an Kindelementen zur Beschreibung allgemeiner Produkteigenschaften. Diese sind die Anzahl (\textit{amount}), der Preis (\textit{price}) und der Hersteller (\textit{manufacturer}). Über das \textit{unit}-Attribut lässt sich der Preis mit unterschiedlichen Währungseinheiten angeben.

Ergänzend zu diesen allgemeinen Angaben besitzt jedes Produkt ein oder zwei bauteilspezifische Datensequenzen, welche die relevanten physikalischen Kenngrößen modellieren. Die Bezeichnung dieser Sequenzen ist vom jeweiligen Bauteiltyp abhängig (\textit{resistance} für Widerstände, \textit{inductance} für Spulen oder \textit{capacitance} für Kondensatoren). Für Dioden können mehrere Kenngrößen angegeben werden (\textit{forwardVoltage} und \textit{reverseVoltage}). Diese Datensequenzen enthalten jeweils eine strukturierte Beschreibung des Zahlenwertes, bestehend aus Mantisse (\textit{value}), Exponent (\textit{exponent}), Einheit (\textit{unit}) sowie optional einer Toleranzangabe (\textit{tolerance}). Der Exponent ist hierbei auf Werte beschränkt, die durch 3 teilbar sind, da nur diese bei den anschließenden Transformationen in Kapitel \ref{sec:Transformationen} in physikalische Vorsilben wie \textmu{}, m, k etc. umgewandelt werden können. Die Toleranz kann über ein \textit{unit}-Attribut entweder relativ (in Prozent) oder absolut angegeben werden. Diese explizite Zuordnung der physikalischen Größen zu den jeweiligen Bauteiltypen erleichtert die in Kapitel \ref{sec:xsd} beschriebene Validierung der XML-Datei mithilfe einer XSD-Datei.



\subsection{XSD-Datei} \label{sec:xsd}

Die manuell erstellte XSD-Datei \texttt{products.xsd} legt fest, welche Elemente, Attribute und Datentypen in der zu validierenden XML-Datei zulässig sind. Sie bildet damit die Grundlage für eine automatisierte Validierung der XML-Datei und stellt sicher, dass die definierten strukturellen und typbezogenen Anforderungen eingehalten werden.

Die Anzahl der \textit{product}-Elemente muss mindestens 1 betragen. Mithilfe von \textit{choice} werden die zulässigen Kombinationen der physikalischen Größen \textit{resistance}, \textit{inductance}, \textit{capacitance}, \textit{forwardVoltage} und \textit{reverseVoltage} zum jeweiligen Bauteil überprüft.

Alle Produkte besitzen die gemeinsamen Attribute \textit{id}, \textit{type} und optional \textit{subtype}, die in einer \textit{attributeGroup} definiert sind. Die bauteilspezifischen Elemente werden jeweils durch einen eigenen \textit{complexType} beschrieben. \textcolor{red}{Die Typisierung der Elemente ohne Attribute erfolgt über die Datentypen wie \textit{float}, \textit{short} oder \textit{string}. Für Attribute werden entweder Standardwerte definiert (z. B. \% bzw. EUR für \textit{unit} als Einheit der Toleranz bzw. der Währung) oder keine Vorgaben gemacht (z. B. für \textit{id}, \textit{type} und \textit{subtype}). Standardwerte sorgen für konsistente Voreinstellungen bei fehlenden Angaben, während feste Werte Abweichungen erkennen und als Fehler kennzeichnen.}

Die Datei \texttt{products-automatic-generated.xsd} wurde durch die in \textit{EditiX} enthaltene automatische Dokumenterstellung generiert. Sie ist allerdings weniger präzise als die bereits beschriebene XSD-Datei. Dies kann damit begründet werden, dass bei der automatischen Generierung nicht die gleichen präzisen Typdefinitionen vorgenommen werden können. Außerdem ist in dieser XSD-Datei kein \textit{choice} enthalten und daher für die Validierung der XML-Datei nur eingeschränkt geeignet. Es wird daher empfohlen, zur Validierung der XML-Datei die XSD-Datei \texttt{products.xsd} zu verwenden. Insbesondere für die in Kapitel \ref{sec:Transformationen} beschriebenen Transformationen muss die XML-Datei die Anforderungen der XSD-Datei \texttt{products.xsd} erfüllen. Die Anforderungen aus der XSD-Datei \texttt{products-automatic-generated.xsd} sind nicht ausreichend.

\textcolor{red}{Was passiert bei Exponenten, die nicht durch 3 teilbar sind? Die Exponenten müssen auch zwischen +9 und -12 liegen. Muss abgeprüft werden!}





\section{Transformationen von XML-Daten} \label{sec:Transformationen}

\subsection{XSLT-Transformation von XML zu HTML} \label{sec:xslt}

Um die Daten aus der XML-Datei auf einer HTML-Website darstellen zu können, wurde eine Transformation mit der erstellten Datei \texttt{products.xslt} durchgeführt. Auf der resultierenden HTML-Website, die unter \texttt{products.html} abgelegt ist, wird für alle 4 Bauteilarten jeweils eine eigene Tabelle erstellt, in der die zugehörigen Bauteildaten angezeigt werden. Diese Tabellen sind zunächst zugeklappt und lassen sich durch das Anklicken Dreieck-Symbols ($\blacktriangleright \; \rightarrow \blacktriangledown$) aufklappen.

Für die Ausgabe der Tabellen wird zwischen Widerständen, Spulen und Kapazitäten sowie Dioden unterschieden, da sich die Anzahl der angegebenen physikalischen Größen unterscheidet. Die Ausgabe der Bauteildaten erfolgt anhand eines Templates, welches für alle physikalischen Größen identisch ist. Dabei werden über \textit{XPath}-Ausdrücke die relevanten Informationen aus der XML-Datei extrahiert. Jede physikalische Größe enthält Mantisse, Exponent, Einheit und optional Toleranz. Die Exponenten werden dabei als physikalische Vorsilben interpretiert, z. B. $10^{-6}$ als \textmu{}. Mit einer \texttt{xsl:when}-Abfrage wird überprüft, ob der optionale Wert für die Toleranz vorhanden ist. Ist dies nicht der Fall, wird ein Bindestrich an der entsprechenden Stelle in der Tabelle angezeigt. Alle weiteren Angaben in der Tabelle sind obligatorisch und werden in jedem Fall ausgegeben. \textcolor{red}{Die Angabe des Exponenten ist fakultativ, aber dieser ist lediglich Bestandteil der physikalischen Größe und besetzt keine spezielle Zelle in der Tabelle. Demzufolge erfolgt auch ohne die Angabe eines Wertes für den Exponenten eine korrekte Darstellung der Tabelle.}



\subsection{FOP-Transformation von XML zu PDF} \label{sec:fop}

Die PDF-Ausgabe der Produktdaten erfolgt über eine FOP-Transformation. Die XSLT-Datei \texttt{products-to-html.xslt} wurde wiederverwendet, um die relevanten Informationen aus der XML-Datei mittels \textit{XPath} zu extrahieren. Die XSL-Transformation erfolgt anhand der XSL-Datei \texttt{products-to-pdf.xsl}, in der im Vergleich zur XSLT-Datei die HTML-Syntax durch FO-Syntax ersetzt und Layout-Anpassungen an der Darstellung vorgenommen wurden. Die Erstellung der FO-Datei \texttt{products.fo}, die FO-Transformation und die anschließende PDF-Erzeugung werden in \textit{EditiX} automatisch durchgeführt, sodass sich die PDF-Datei \texttt{products.pdf} ergibt.

Ein spezieller Anpassungspunkt besteht in der Darstellung des Symbols $\Omega$ als Einheit des Widerstands. Im Vergleich zu anderen Zeichen musste es um 0.145\,em nach oben verschoben werden, damit die Zeilenhöhe im Vergleich zu den vorherigen Zeichen erhalten bleibt.

Die in den Kapiteln \ref{sec:xslt} und \ref{sec:fop} beschriebenen Transformationen sind generisch und können somit für jede XML-Datei durchgeführt werden, welche die Anforderungen der in Kapitel \ref{sec:xsd} erläuterten XSD-Datei erfüllen.





\section{Programmierung} \label{sec:Programmierung}

\subsection{Grundlegende Informationen}

Durch die XML-Programmierung sollen folgende Funktionalitäten implementiert werden:

\begin{enumerate}
    \item Validierung eines XML-Dokuments gegen ein XSD-Schema
    \item Abfrage von Informationen aus einem XML-Dokument
    \item Transformation eines XML-Dokuments in eine HTML-Website
\end{enumerate}

Zur Umsetzung dieser Funktionalitäten wird im Rahmen dieses Projekts die Programmiersprache \textit{Python} verwendet. Um das die in den folgenden Kapiteln beschriebenen Befehle in der Kommandozeile ausführen zu können, muss \textit{Python} von der offiziellen Website https://www.python.org unter dem Reiter \textit{Downloads} installiert werden. Für dieses Projekt wurde Version 3.12.8 genutzt. Außerdem müssen die beiden Module \textit{lxml} und \textit{tkinter} installiert werden.

Durch das Modul \textit{lxml} ist es möglich, diese Funktionalitäten umzusetzen.



Damit die Befehle über die Kommandozeile aufgerufen werden können, muss zunächst ein lokaler Python Download erfolgen.

HIER MUSS ICH ES MAL MIT MEINEM EIGENEN LINUX SYSTEM PROBIEREN!




Für alle 3 Teilaufgaben existieren 3 getrennte Python-Dateien:

\begin{enumerate}
    \item Backend-Datei (\texttt{*\_backend.py}): enthält ausschließlich die Logik der jeweiligen Aufgabe und können nicht direkt ausgeführt werden
    \item Projektmodus-Datei (\texttt{*\_from\_project.py}): führt die jeweilige Aufgabe mit den im Projekt erarbeiteten Dateien aus
    \item Interaktiv-Datei (\texttt{*\_interactive.py}): ermöglicht die Auswahl beliebiger Dateien und führt die jeweilige Aufgabe für diese durch
\end{enumerate}

Die jeweiligen Dateien enthalten den beschriebenen Code, der ausführlich kommentiert ist. Die Dateien können ausgeführt werden, indem man zunächst die virtuelle Umgebung aktiviert und in der Kommandizeile in das Verzeichnis \texttt{programming/src} wechselt und den Befehl \texttt{python\ desired\_file.py} ausführt. Dabei ist \texttt{desired\_file.py} ein Platzhalter für den eigentlichen Dateinamen, der an dieser Stelle natürlich eingesetzt werden muss.



\subsection{Abfrage}

Bei der Abfrage werden gezielt Informationen aus einem XML-Dokument extrahiert, indem XPath verwendet wird. Hierbei werden 3 verschiedene Abfragen durchgeführt:

\begin{enumerate}
    \item Welche Produkt-IDs gibt es?
    \item Wie heißen die Hersteller? (Hierbei sollen mehrfach aufgeführte Hersteller nur einmal aufgeführt werden.)
    \item Was ist die Gesamtanzahl aller Widerstände im Lager?
\end{enumerate}

Führt man die Datei \texttt{query\_from\_project.py} für den Projektmodus aus, dann wird in der Kommandozeile folgendes ausgegeben:

\begin{verbatim}
Query 1: Retrieve all product IDs.
Result: ['R001', 'R002', 'R003', 'L001', 'L002', 'C001', 'C002', 
        'D001', 'D002']

Query 2: Retrieve unique manufacturer names.
Result: ['Diodes Incorporated', 'Micro Commercial Components', 
        'Murata Power Solutions', 'Samsung Electro-Mechanics', 
        'Stackpole Electronics', 'Taiyo Yuden']

Query 3: Calculate the total number of resistors in stock.
Result: 864907
\end{verbatim}

Möchte man die interaktive Abfrage durchführen, kann man über die Datei \texttt{query\_from\_project.py} eine XML-Datei aus dem Datei-Explorer auswählen. Anschließend wird zunächst überprüft, ob die angegebene Datei das vorgegebene XSD-Schema erfüllt. Ist dies nicht der Fall, können die Abfragen nicht durchgeführt werden und es wird eine Fehlermeldung ausgegeben. Ist die XML-Datei gültig, werden ebenfalls die 3 Abfragen getätigt und die Ergebnisse ausgegeben.



\subsection{Validierung}

Um eine XML-Datei gegen ein XSD-Schema validieren zu können, kommen die Dateien \texttt{validate\_from\_project.py} und \texttt{validate\_interactive.py} zur Anwendung. Dabei kann in ersterem Fall die XML-Datei gegen die XSD-Datei aus dem gegebenen Projekt validiert werden. Für die zweite Datei ist die Auswahl einer beliebigen XML- und XSD-Datei im Datei-Explorer möglich. Die Ausgabe in der Kommandozeile für eine gültige oder nicht gültige XML-Datei lautet folgendermaßen (kommt auch mit automatisch generierter XSD raus):

\begin{verbatim}
VALIDATION RESULT: products.xml is valid according to products.xsd

VALIDATION RESULT: products.xml is NOT valid according to products.xsd
\end{verbatim}



\subsection{Transformation}

Die Transformation erfolgt über die Dateien \texttt{transfrom\_from\_project.py} und \texttt{transform\_interactive.py}. Dabei wird entweder die XML- und XSLT-Datei des gegebenen Projekts verwendet oder im interaktiven Modus werden diese beiden Dateitypen vom Anwender übergeben. Anschließend wird die Transformation in eine HTML-Datei durchgeführt und in den \textit{output}-Ordner (in \textit{programming}) gelegt, sodass sich der Anwender die entstehende HTML-Website anschauen kann. Im interaktiven Modus kann sich der Anwender den Zielordner selsbt aussuchen. In der Kommandozeile kommt der Hinweis:

\begin{verbatim}
HTML generated: products.html
\end{verbatim}

Im Unterordner \textit{programming/output} befindet sich bereits die HTML-Datei, die durch die durchgeführte Transformation für die im Projekt gegebenen Dokumente entstanden ist.

\end{document}
