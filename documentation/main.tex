\documentclass[
paper = a4,
fontsize = 12pt,
numbers=noenddot,
headsepline = true,
footsepline = true,
plainfootsepline = true,
parskip,								        
listof = nottotoc,
bibliography = totoc,
index = totoc,
twoside = false
]{scrartcl}



\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}

\usepackage{color} 
\usepackage{tikz}
\usetikzlibrary{arrows.meta, calc, positioning, shapes.symbols, shapes.misc}

\usepackage{geometry}
\geometry{
    left=3cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}

\usepackage{setspace}
\onehalfspacing

\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage[hidelinks]{hyperref}
\usepackage{enumitem}
\usepackage{scrlayer-scrpage}
\clearpairofpagestyles

\usepackage{xcolor}
\usepackage{longtable}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}

% Automatische Marken für scrartcl: section
\automark{section}

% Linienfarbe
\addtokomafont{headsepline}{\color{mygray}}
\addtokomafont{footsepline}{\color{mygray}}

% Kopfzeile: rechts Abschnittsname
\ohead{\color{mygray}\leftmark}

% Fußzeile: Seitenzahl mittig
\cfoot{\color{mygray}\pagemark}

% Auch für plain-Seiten (TOC etc.) erzwingen
\pagestyle{scrheadings}

\setlength{\footskip}{1.2cm}



% Titelinformationen
\title{
    \textbf{\\[2cm] Dokumentation zum XML-Projekt im Master-Modul Internettechnologie}     \vspace{1cm}
}

\author{
    \Large{\textbf{Lennart Mende}} \\
    \Large{\textbf{Richard Mende}} \\[2cm]
    \large{HTWK Leipzig} \\
    \large{Wintersemester 2025/26} \\
    \large{Prof. Dr.-Ing. Andreas Pretschner}
}

\date{\vspace{3cm}\large{\today}}


\begin{document}



% Titelseite
\maketitle

\thispagestyle{empty}

\newpage

% Inhaltsverzeichnis
\tableofcontents

\vspace{2cm}

% Abbildungsverzeichnis

\section*{Abkürzungsverzeichnis}

\renewcommand{\arraystretch}{1.5}

\begin{longtable}[l]{@{}ll@{}}
\textbf{Abkürzung} & \textbf{Bedeutung} \\[1mm]

FO & Formatting Objects \\ 
HTML & HyperText Markup Language \\ 
PDF & Portable Document Format \\ 
XML & eXtensible Markup Language \\ 
XSD & XML Schema Definition \\ 
XSL & eXtensible Stylesheet Language \\ 
XSLT & XSL Transformations \\

\end{longtable}

\renewcommand{\arraystretch}{1}

% Römische Seitennummerierung starten
\pagenumbering{Roman}
\setcounter{page}{1}

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}





% Hauptteil

\section{Projektübersicht}

\subsection{Zielstellung}

Als Grundlage dieses Projekts dient das Anlegen eines XML-Datensatzes, der aus mehreren Objekten besteht. Jedes Objekt soll mindestens ein Attribut sowie eine Datensequenz enthalten. Auf Basis dieses Datensatzes wird eine XSD-Datei erstellt, sodass die XML-Datei validiert werden kann. Dabei wird überprüft, ob die XML-Datei der definierten Struktur entspricht und alle erforderlichen Angaben enthalten sind. Zusätzlich wird eine XSD-Datei mithilfe der in \textit{EditiX} integrierten automatischen Dokumenterstellung generiert.

Der zweite Teil des Projekts befasst sich mit der Transformation der XML-Datei in zwei unterschiedliche Ausgabeformate. Zunächst sollen die Daten aus der XML-Datei in Form einer HTML-Seite dargestellt werden, wofür eine XSLT-Transformationsdatei erstellt werden muss. Darüber hinaus wird eine FOP-Transformation, um aus der XML-Datei eine PDF-Datei zu generieren. Eine schematische Übersicht dieser Transformationen zeigt \autoref{fig:files}.

Der dritte Aufgabenteil beschäftigt sich mit der XML-Programmierung. Dabei soll eine Applikation erstellt werden, welche die Validierung, Abfrage und Transformation der XML-Datei ermöglicht.

\enlargethispage{1\baselineskip}

\begin{figure}[H]
\centering
\begin{tikzpicture}[>=Stealth, thick]

% ---------------- Parameter ----------------
\def\filewidth{1.8}
\def\fileheight{2.7}
\def\fold{0.5}
\def\scale{1}

\def\dx{3.3}     % horizontaler Abstand
\def\dy{2}       % vertikaler Versatz der Pfade

% ---------------- XML (Mittellinie) ----------------
\node (xml) at (0,0) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XML};
\end{tikzpicture}
};

% ---------------- XSD ----------------
\node (xsd) [below=of xml] {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XSD};
\end{tikzpicture}
};

\draw[<->] (xsd) -- (xml);

% ---------------- Unterer Pfad: XSL → FO → PDF ----------------
\node (xsl) at (\dx,-\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XSL};
\end{tikzpicture}
};

\node (fo) at (2*\dx,-\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\node at (\filewidth/2,\fileheight/2) {FO};
\end{tikzpicture}
};

\node (pdf) at (3*\dx,-\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\node at (\filewidth/2,\fileheight/2) {PDF};
\end{tikzpicture}
};

% ---------------- Oberer Pfad: XSLT → HTML ----------------
\node (xslt) at (\dx,\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\draw (\filewidth-\fold,\fileheight)--(\filewidth,\fileheight-\fold);
\node at (\filewidth/2,\fileheight/2) {XSLT};
\end{tikzpicture}
};

\node (html) at (3*\dx,\dy) {
\begin{tikzpicture}[x=\scale cm,y=\scale cm]
\draw[fill=white]
(0,0)--(0,\fileheight)--(\filewidth-\fold,\fileheight)--
(\filewidth,\fileheight-\fold)--(\filewidth,0)--cycle;
\draw[fill=white]
(\filewidth-\fold,\fileheight)--(\filewidth-\fold,\fileheight-\fold)--
(\filewidth,\fileheight-\fold)--cycle;
\node at (\filewidth/2,\fileheight/2) {HTML};
\end{tikzpicture}
};

% ---------------- Pfeile: horizontale Aufteilung ----------------

\draw[->] (xml.north east) -- (xslt.west);
\draw[->] (xml.south east) -- (xsl.west);

\draw[->] (xsl) -- (fo);
\draw[->] (fo) -- (pdf);

\draw[->] (xslt) -- (html);

\end{tikzpicture}
\caption{Übersicht der Dokumenttypen und Transformationspfade}
\label{fig:files}
\end{figure}



\subsection{Projektorganisation}

Zur strukturierten Umsetzung des Projekts sowie zur Sicherstellung einer nachvollziehbaren Versionsverwaltung wurde ein öffentlich zugängliches \textit{GitHub-Repository} unter \url{https://github.com/rimen13/Projekt_Internettechnologie} eingerichtet. Die Gliederung der Projektdateien ergibt sich folgendermaßen:

\vspace{-5mm}
{\fontsize{11pt}{11pt}\selectfont
\begin{verbatim}
project/
|-- assets/
|   |-- src/
|   |   |-- products.xml
|   |   |-- products.xsd
|   |   |-- products-automatic-generated.xsd
|   |   |-- products-to-html.xslt
|   |   |-- products-to-pdf.xsl
|   |   |-- products-validation.xml
|   |-- output/
|       |-- products.html
|       |-- products.fo
|       |-- products.pdf
|-- documentation/
|   |-- documentation.pdf
|-- programming/
    |-- src/
    |   |-- query_backend.py
    |   |-- query_from_project.py
    |   |-- query_interactive.py
    |   |-- validate_backend.py
    |   |-- validate_from_project.py
    |   |-- validate_interactive.py
    |   |-- transform_backend.py
    |   |-- transform_from_project.py
    |   |-- transform_interactive.py
    |-- output/
    |   |-- products.html
    |-- requirements.txt
\end{verbatim}
}

Als Entwicklungswerkzeuge kamen der XML-Editor \textit{EditiX} zur Erstellung der Dateien im Ordner \texttt{assets} sowie \textit{Visual Studio Code} als integrierte Entwicklungsumgebung zur Umsetzung der XML-Programmierung zum Einsatz. Die inhaltliche Ausarbeitung orientiert sich an den Modul-Unterlagen auf Moodle. Die in der XML-Datei verwendeten Preise und Stückzahlen der elektronischen Bauteile basieren auf den Angaben der Websites \url{https://www.digikey.de} und \url{https://www.mouser.de}. Außerdem wurde ChatGPT als Unterstützung bei der sprachlichen Gestaltung der Dokumentation, der FO-Syntax und der Programmierung eingesetzt. Als fachliche Grundlage diente das Buch \glqq Beginning XML\grqq{} von David Hunter et al. (2007, 4. Auflage).




\section{Datensatz} \label{sec:datensatz}

\subsection{XML-Datei}

Als Beispieldatensatz für dieses Projekt wurde ein Katalog elektronischer Bauteile eines fiktiven Elektronikshops modelliert. Der vollständige Datensatz ist in der Datei \texttt{products.xml} abgelegt und umfasst insgesamt 9 unterschiedliche Bauteile (3 Widerstände, 2 Spulen, 2 Kondensatoren und 2 Dioden). Das XML-Dokument besitzt das Root-Element \textit{products}, unter dem alle \textit{product}-Elemente zusammengefasst sind. Jedes \textit{product}-Element repräsentiert ein einzelnes Bauteil und stellt damit ein Objekt des Datensatzes dar, welches über das Attribut \textit{id} eindeutig zu identifizieren ist. Zusätzlich wird über das Attribut \textit{type} der grundlegende Bauteiltyp spezifiziert, bei Dioden erweitert durch das Attribut \textit{subtype}. Unabhängig vom konkreten Bauteiltyp enthalten alle \textit{product}-Elemente eine einheitliche Menge an Kindelementen zur Beschreibung allgemeiner Produkteigenschaften. Diese sind die Anzahl (\textit{amount}), der Preis (\textit{price}) und der Hersteller (\textit{manufacturer}). Über das \textit{unit}-Attribut lässt sich der Preis mit unterschiedlichen Währungseinheiten angeben.

Ergänzend zu diesen allgemeinen Angaben besitzt jedes Produkt ein oder zwei bauteilspezifische Datensequenzen, welche die relevanten physikalischen Kenngrößen modellieren. Die Bezeichnung dieser Sequenzen ist vom jeweiligen Bauteiltyp abhängig (\textit{resistance} für Widerstände, \textit{inductance} für Spulen oder \textit{capacitance} für Kondensatoren). Für Dioden können mehrere Kenngrößen angegeben werden (\textit{forwardVoltage} und \textit{reverseVoltage}). Diese Datensequenzen enthalten jeweils eine strukturierte Beschreibung des Zahlenwertes, bestehend aus Mantisse (\textit{value}), Exponent (\textit{exponent}), Einheit (\textit{unit}) sowie optional einer Toleranzangabe (\textit{tolerance}). Diese Toleranzangabe erfolgt über ein \textit{unit}-Attribut und kann entweder relativ (in Prozent) oder absolut angegeben werden. Diese explizite Zuordnung der physikalischen Größen zu den jeweiligen Bauteiltypen erleichtert die in Kapitel \ref{sec:xsd} beschriebene Validierung der XML-Datei mithilfe einer XSD-Datei.



\subsection{XSD-Datei} \label{sec:xsd}

Die manuell erstellte XSD-Datei \texttt{products.xsd} legt fest, welche Elemente, Attribute und Datentypen in der zu validierenden XML-Datei zulässig sind. Sie bildet damit die Grundlage für eine automatisierte Validierung der XML-Datei und stellt sicher, dass die definierten strukturellen und typbezogenen Anforderungen eingehalten werden. Zur direkten Validierung der XML-Datei gegen diese XSD-Datei in \textit{EditiX} dient die XML-Datei \texttt{products-validation.xml}. Diese enthält einen Verweis auf die XSD-Datei \textit{products.xsd}, sodass die XML-Datei automatisch gegen die XSD-Datei validiert wird.

Die Anzahl der \textit{product}-Elemente muss mindestens 1 betragen. Mithilfe von \textit{choice} werden die zulässigen Kombinationen der physikalischen Größen \textit{resistance}, \textit{inductance}, \textit{capacitance}, \textit{forwardVoltage} und \textit{reverseVoltage} zum jeweiligen Bauteil überprüft.

Alle Produkte besitzen die gemeinsamen Attribute \textit{id}, \textit{type} und optional \textit{subtype}, die in einer \textit{attributeGroup} definiert sind. Die bauteilspezifischen Elemente werden jeweils durch einen eigenen \textit{complexType} beschrieben. Die Typisierung einfacher Elemente ohne Attribute erfolgt entweder direkt über die Schema-Datentypen wie \textit{float}, \textit{short} oder \textit{string}, oder über benutzerdefinierte \textit{simpleTypes} bzw. \textit{complexTypes} mit einfachem Inhalt, wie beispielsweise \textit{ExponentType}, \textit{ToleranceType} oder \textit{PriceType}. Für Attribute werden entweder Standardwerte definiert (z. B. \% bzw. EUR für \textit{unit} als Einheit der Toleranz bzw. Währung) oder keine Vorgaben gemacht (z. B. für \textit{id}, \textit{type} und \textit{subtype}). Standardwerte sorgen für konsistente Voreinstellungen bei fehlenden Angaben, während feste Werte Abweichungen erkennen und als Fehler kennzeichnen.

Der Exponent ist auf eine diskrete Menge vordefinierter Werte beschränkt, die ganzzahlige Vielfache von 3 sind und im Bereich von -12 bis 9 liegen. Diese Einschränkung wurde mit \textit{ExponentType} als \textit{enumeration} umgesetzt, da ausschließlich diese Exponenten in den anschließenden Transformationen in Kapitel \ref{sec:Transformationen} in physikalische Vorsilben wie \textmu{}, m oder k überführt werden können.

Die Datei \texttt{products-automatic-generated.xsd} wurde durch die in \textit{EditiX} enthaltene automatische Dokumenterstellung generiert. Sie ist allerdings weniger präzise als die bereits beschriebene XSD-Datei. Dies kann damit begründet werden, dass bei der automatischen Generierung nicht die gleichen präzisen Typdefinitionen vorgenommen werden können. Außerdem ist in dieser XSD-Datei kein \textit{choice} enthalten und daher für die Validierung der XML-Datei nur eingeschränkt geeignet. Es wird daher empfohlen, zur Validierung der XML-Datei die XSD-Datei \texttt{products.xsd} zu verwenden. Insbesondere für die in Kapitel \ref{sec:Transformationen} beschriebenen Transformationen muss die XML-Datei die Anforderungen der XSD-Datei \texttt{products.xsd} erfüllen. Die Anforderungen aus der XSD-Datei \texttt{products-automatic-generated.xsd} sind nicht ausreichend.





\section{Transformationen von XML-Daten} \label{sec:Transformationen}

\subsection{XSLT-Transformation von XML zu HTML} \label{sec:xslt}

Um die Daten aus der XML-Datei auf einer HTML-Website darstellen zu können, wurde eine Transformation mit der erstellten Datei \texttt{products-to-html.xslt} durchgeführt. Auf der resultierenden HTML-Website, die unter \texttt{products.html} abgelegt ist, wird für alle 4 Bauteilarten jeweils eine eigene Tabelle erstellt, in der die zugehörigen Bauteildaten angezeigt werden. Diese Tabellen sind zunächst zugeklappt und lassen sich durch Anklicken des Dreieck-Symbols ($\blacktriangleright \; \rightarrow \blacktriangledown$) aufklappen.

Für die Ausgabe der Tabellen wird zwischen Widerständen, Spulen und Kapazitäten sowie Dioden unterschieden, da sich die Anzahl der angegebenen physikalischen Größen unterscheidet. Die Ausgabe der Bauteildaten erfolgt anhand eines Templates, welches für alle physikalischen Größen identisch ist. Dabei werden über \textit{XPath}-Ausdrücke die relevanten Informationen aus der XML-Datei extrahiert. Jede physikalische Größe enthält Mantisse, Exponent, Einheit und optional Toleranz. Die Exponenten werden dabei als physikalische Vorsilben interpretiert, z. B. $10^{-6}$ als \textmu{}. Mit einer \texttt{xsl:when}-Abfrage wird überprüft, ob der optionale Wert für die Toleranz vorhanden ist. Ist dies nicht der Fall, wird ein Bindestrich an der entsprechenden Stelle in der Tabelle angezeigt. Alle weiteren Angaben in der Tabelle sind, mit Ausnahme des Exponenten, obligatorisch und werden stets ausgegeben. Der Exponent ist optional und stellt lediglich einen Bestandteil der physikalischen Größe dar, ohne eine eigene Tabellenzelle zu belegen. Dementsprechend ist auch ohne Angabe eines Exponenten eine korrekte Darstellung der Tabelle gewährleistet.



\subsection{FOP-Transformation von XML zu PDF} \label{sec:fop}

Die PDF-Ausgabe der Produktdaten erfolgt über eine FOP-Transformation. Die XSLT-Datei \texttt{products-to-html.xslt} wurde wiederverwendet, um die relevanten Informationen aus der XML-Datei mittels \textit{XPath} zu extrahieren. Die XSL-Transformation erfolgt anhand der XSL-Datei \texttt{products-to-pdf.xsl}, in der im Vergleich zur XSLT-Datei die HTML-Syntax durch FO-Syntax ersetzt und Layout-Anpassungen an der Darstellung vorgenommen wurden. Die Erstellung der FO-Datei \texttt{products.fo} und die FOP-Transformation erfolgt in \textit{EditiX} automatisch, sodass anschließend die PDF-Datei \texttt{products.pdf} generiert wird.

Ein spezieller Anpassungspunkt besteht in der Darstellung des Symbols $\Omega$ als Einheit des Widerstands. Im Vergleich zu anderen Zeichen musste es um 0.145\,em nach oben verschoben werden, damit die Zeilenhöhe im Vergleich zu den vorherigen Zeichen erhalten bleibt.

Die in den Kapiteln \ref{sec:xslt} und \ref{sec:fop} beschriebenen Transformationen sind generisch und können somit für jede XML-Datei durchgeführt werden, welche die Anforderungen der in Kapitel \ref{sec:xsd} erläuterten XSD-Datei erfüllen.





%\vspace{1cm}
\section{Programmierung}
\label{sec:Programmierung}

\subsection{Grundlegende Informationen}

In diesem Projekt sollen folgende Funktionalitäten umgesetzt werden:

\begin{enumerate}[itemsep=0pt,parsep=6pt]
    \item Validierung einer XML-Datei gegen eine XSD-Datei
    \item Abfrage ausgewählter Informationen aus einer XML-Datei
    \item XSLT-Transformation einer XML-Datei zu einer HTML-Website
\end{enumerate}

Zur Implementierung dieser Funktionalitäten wurde die Programmiersprache \textit{Python} verwendet, da sie leistungsfähige Bibliotheken für die Verarbeitung von XML-Dateien bereitstellt. Über die Bibliothek \texttt{lxml} können XML-Parsing, Schema-Validierung und XSLT-Transformationen durchgeführt werden. Für die Programmierung der Funktionalitäten wurden insgesamt 9 Dateien erstellt, die sich folgendermaßen gliedern:

\begin{enumerate}[itemsep=6pt,parsep=6pt]
    \item \textbf{Backend-Dateien (\texttt{*\_backend.py})} \\
    Diese Dateien enthalten ausschließlich die Logik der jeweiligen Aufgabe (Abfrage, Validierung, Transformation). Sie werden von den Projekt- und Interaktiv- \linebreak modus-Dateien aufgerufen, wobei die entsprechenden Dateipfade übergeben werden.

    \item \textbf{Projektmodus-Dateien (\texttt{*\_from\_project.py})} \\
    Diese Dateien führen die jeweilige Aufgabe für die in diesem Projekt verwendeten Dateien aus. Darin werden die Dateipfade bestimmt und anschließend an die jeweilige Backend-Datei übergeben. 

    \item \textbf{Interaktivmodus-Dateien (\texttt{*\_interactive.py})} \\
    Diese Dateien ermöglichen dem Anwender die Auswahl beliebiger XML-, XSD- oder XSLT-Dateien über ein sich öffnendes Fenster. Dies wird durch die Verwendung des Moduls \texttt{tkinter} realisiert. Anschließend werden die Dateipfade an die jeweilige Backend-Datei übergeben.
\end{enumerate}

Um die Dateien auszuführen, muss Python in der Version 3.12.8 (oder neuer) installiert sein. Für dieses Projekt wurden außerdem die Module \texttt{lxml} und \texttt{tkinter} verwendet, welche über eine virtuelle Umgebung installiert werden können. Der Aufruf der einzelnen Dateien erfolgt über die Kommandozeile. Dafür muss zunächst die virtuelle Umgebung aktiviert und anschließend in das Verzeichnis \texttt{programming/src} gewechselt werden. Anschließend kann der Befehl \texttt{python validate\_from\_project.py} ausgeführt werden. Dabei kann \texttt{validate\_from\_project.py} durch die 5 weiteren Dateinamen \texttt{validate\_interactive.py}, \texttt{query\_from\_project.py}, \texttt{query\_interactive.py}, \texttt{transform\_from\_project.py} und \texttt{transform\_interactive.py} ersetzt werden. Die 3 Backend-Dateien können prinzipiell ebenfalls aufgerufen werden, liefern allerdings kein Ergebnis.



\subsection{Validierung}

Die Validierung eines XML-Dokuments gegen ein XSD-Schema erfolgt in der Datei \texttt{validate\_backend.py}. Dabei werden sowohl das XML-Dokument als auch die XSD-Datei mithilfe von \texttt{etree.parse()} eingelesen. Anschließend wird aus der XSD-Datei ein \texttt{XMLSchema}-Objekt erzeugt, welches die in der Schema-Datei definierten Struktur- und Typregeln bereitstellt. Die eigentliche Validierung erfolgt durch den Aufruf der Methode \texttt{schema.validate(xml\_doc)}. Bei erfolgreicher Validierung wird in der Kommandozeile eine entsprechende Erfolgsmeldung ausgegeben. Schlägt die Validierung fehl, wird zusätzlich das Fehlerprotokoll des Schemas ausgegeben, welches detaillierte Informationen zur Art und Position der Regelverletzungen enthält.

Beim Ausführen der Datei \texttt{validate\_from\_project.py} werden die in diesem Projekt enthaltene XML-Datei und die zugehörige XSD-Datei an die Backend-Datei übergeben. Nach Abschluss der Validierung wird in der Kommandozeile das Ergebnis \texttt{VALIDATION RESULT: products.xml is valid according to products.xsd} ausgegeben. Im interaktiven Modus über die Datei \texttt{validate\_interactive.py} kann der Anwender in einem sich öffnenden Fenster beliebige XML- und XSD-Dateien auswählen.



\subsection{Abfrage}

Die Abfrage von Daten aus einer XML-Datei ist in der Datei \texttt{query\_backend.py} implementiert und nutzt \textit{XPath}-Ausdrücke zur gezielten Extraktion von Informationen aus der XML-Datei. Zu Beginn wird das XML-Dokument mithilfe der Funktion \texttt{etree.parse(xml\_path)} eingelesen. Diese Funktion liest die übergebene XML-Datei ein und erzeugt einen internen XML-Baum, auf dem anschließend \textit{XPath}-Abfragen ausgeführt werden können.

Da das verwendete XML-Dokument einen Namespace definiert, ist es erforderlich, ein entsprechendes Namespace-Mapping zu definieren. Die \textit{XPath}-Abfragen müssen diesen Namespace explizit berücksichtigen, da andernfalls keine Elemente gefunden würden. Anschließend werden drei \textit{XPath}-Abfragen durchgeführt:

\begin{enumerate}
    \item \textbf{Ermittlung aller Produkt-IDs} \\
    Über den \textit{XPath}-Ausdruck \texttt{//p:product/@id} werden alle \texttt{id}-Attribute sämtlicher Produkte extrahiert. Das Ergebnis ist eine Liste von Zeichenketten.

    \item \textbf{Abfrage aller eindeutigen Hersteller} \\
    Mit dem \textit{XPath}-Ausdruck \texttt{//p:product/p:manufacturer/text()} werden alle in der XML-Datei enthaltenen Herstellernamen ausgelesen. Da einzelne Hersteller mehrfach auftreten können, werden mehrfach aufgeführte Hersteller mithilfe der Python-Funktionen \texttt{set()} und \texttt{sorted()} herausfiltert. Als Ergebnis wird die alphabetisch sortierte Liste der Hersteller ausgegeben.

    \item \textbf{Berechnung der Gesamtanzahl von Widerständen}  
    Mithilfe eines \textit{XPath}-Ausdrucks werden gezielt Produkte mit dem Attribut \texttt{type='resistor'} ausgewählt und deren \texttt{amount}-Werte extrahiert. Diese werden anschließend aufsummiert und das Ergebnis ausgegeben.
\end{enumerate}

Die Datei \texttt{query\_from\_project.py} ruft diese Backend-Funktion mit der projektspezifischen XML-Datei auf und gibt die Ergebnisse in der Kommandozeile aus:
\begin{verbatim}
Query 1: Retrieve all product IDs.
Result: ['R001', 'R002', 'R003', 'L001', 'L002', 'C001', 'C002', 
        'D001', 'D002']

Query 2: Retrieve unique manufacturer names.
Result: ['Diodes Incorporated', 'Micro Commercial Components', 
        'Murata Power Solutions', 'Samsung Electro-Mechanics', 
        'Stackpole Electronics', 'Taiyo Yuden']

Query 3: Calculate the total number of resistors in stock.
Result: 864907
\end{verbatim}
Im interaktiven Modus (\texttt{query\_interactive.py}) kann der Anwender aus einem sich öffnenden Fenster die XML-Datei auswählen, aus welcher er die Daten abfragen möchte. Allerdings können die beschriebenen Abfragen nur für XML-Dateien durchgeführt werden, welche die Validierung gegen die XSD-Datei \texttt{products.xsd} erfüllen. Demzufolge wird zunächst über die Backend-Datei der Validierung \texttt{validate\_backend.py} überprüft, ob die ausgewählte XML-Datei valide ist. Ist dies der Fall, werden auch hier die Ergebnisse der Abfragen in der Kommandozeile ausgegeben. Andernfalls bricht das Programm mit einem entsprechenden Hinweis ab.



\subsection{Transformation}

Die Transformation einer XML-Datei in eine HTML-Website mithilfe einer XSLT-Datei ist in der Datei \texttt{transform\_backend.py} implementiert. Zu Beginn werden sowohl die übergebene XML-Datei als auch die zugehörige XSLT-Datei mithilfe der Funktion \texttt{etree.parse()} eingelesen. Anschließend wird aus der XSLT-Datei mittels \texttt{etree.XSLT()} ein Transformationsobjekt erzeugt. Dieses Objekt enthält die in der XSLT-Datei definierten Template-Regeln. Die eigentliche Transformation erfolgt durch den Aufruf dieses Transformationsobjekts auf das geparste XML-Dokument. Das Ergebnis ist ein neues Dokumentenobjekt, das die transformierte HTML-Struktur enthält und anschließend als HTML-Datei gespeichert wird.

Die Datei \texttt{transform\_from\_project.py} ruft diese Backend-Funktion mit den projektspezifischen XML- und XSLT-Dateien auf und legt die erzeugte HTML-Datei im vorgesehenen Ausgabeverzeichnis ab. Im interaktiven Modus (\texttt{transform\_interactive.py}) kann der Anwender sowohl die Eingabedateien als auch den Zielpfad frei wählen.

Nach erfolgreicher Transformation wird der Anwender in der Kommandozeile über die Erstellung der HTML-Datei mit dem Hinweis \texttt{HTML generated: products.html} informiert. Diese durch die Projektdokumente erzeugte HTML-Datei \texttt{products.html} befindet sich bereits im Unterordner \texttt{programming/output}.

\end{document}
